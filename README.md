# Secure Code Review Examples

This repository contains a collection of intentionally vulnerable code snippets and my security review feedback.

## Purpose

These code review exercises were created to practice and demonstrate security code review skills for application security engineering roles. Each snippet has been generated by Anthropic's Claude Sonnet 4.5 and contains multiple security vulnerabilities. I identified and documented each vulnerability with detailed explanations and remediation guidance, sometimes focussing on coverage rather than depth. Note that I only spend a few minutes on each snippet, so the analysis is cursory and may miss some nuances. In a real situation, the interviewer would ask follow up questions where needed to probe deeper into the identified issues or challenge assumptions or call-outs during the review process.

## Contents

- [SQL Injection in Rails controller](https://github.com/fwpt/secure-code-review?tab=readme-ov-file#sql-injection-in-rails-controller)
- [Broken Access Control (IDOR) in user profile update](https://github.com/fwpt/secure-code-review?tab=readme-ov-file#broken-access-control-idor-in-user-profile-update)
- [Sensitive Data Exposure (password logging) in authentication](https://github.com/fwpt/secure-code-review?tab=readme-ov-file#sensitive-data-exposure-password-logging-in-authentication)
- [Path Traversal vulnerability in file handling](https://github.com/fwpt/secure-code-review?tab=readme-ov-file#path-traversal-vulnerability-in-file-handling)
- [Race Condition (TOCTOU) and CSRF in financial transaction API](https://github.com/fwpt/secure-code-review?tab=readme-ov-file#race-condition-toctou-and-csrf-in-financial-transaction-api)
- [Command Injection (RCE) and JWT vulnerabilities in Node.js/Express](https://github.com/fwpt/secure-code-review?tab=readme-ov-file#command-injection-rce-and-jwt-vulnerabilities-in-nodejsexpress)
- [Container security issues (secrets, root user, SSH exposure)](https://github.com/fwpt/secure-code-review?tab=readme-ov-file#container-security-issues-secrets-root-user-ssh-exposure)

There is some repetition and I refer back to previous findings in my feedback, so it's best to read through these from top to bottom for maximum learning.

## Methodology

For each code snippet, my review process includes:

1. **Initial scan** - Quick overview to identify the code's purpose and potential risk areas
2. **Line-by-line analysis** - Detailed examination of each component (only viable for short snippets)
3. **Vulnerability identification** - Pinpointing specific security issues
4. **Impact assessment** - Explaining the potential consequences
5. **Remediation guidance** - Providing concrete fixes and best practices

## Coverage

These reviews cover vulnerabilities from the OWASP Top 10 and beyond:

- SQL Injection
- Broken Access Control (IDOR)
- Sensitive Data Exposure
- Security Misconfiguration
- Cross-Site Request Forgery (CSRF)
- Command Injection (Remote Code Execution)
- Path Traversal
- Race Conditions (TOCTOU)
- JWT Security Issues
- Container Security
- Secrets Management
- Input Validation

## Important Context

**These code snippets were intentionally created with vulnerabilities for educational and demonstration purposes.** They should not be used in production environments. The security reviews represent my analysis and approach to identifying and remediating security issues.

### Communication Style Note

The feedback provided in these reviews reflects a **conversational, interview-style approach** when discussing security issues with another security engineer or in a technical assessment context. The tone is direct and focused on identifying vulnerabilities.

**In real-world collaboration with development teams**, I adapt my communication style significantly:

- **Balanced feedback** - I acknowledge what's done well alongside areas for improvement
- **Constructive tone** - I frame security issues as opportunities to secure the codebase, not as criticism
- **Collaborative approach** - I work with developers as partners, understanding constraints and trade-offs
- **Empathy** - I understand that pointing out only "bad" things can feel personal and demotivating

The reviews here focus exclusively on vulnerabilities for demonstration purposes, but in practice, I believe effective security engineering requires building trust and also celebrating good security practices when I see them.

## Additional Findings

After completing the initial reviews, I asked Claude to review my work and also come up with items that I might have missed in the first pass. I leave it as an exercise for the reader: can you find more issues? Create a PR against these files if you do!

## About

These reviews demonstrate my security engineering skills including:
- Deep understanding of common vulnerability classes
- Ability to identify both obvious and subtle security issues
- Knowledge of secure coding practices across multiple languages
- Practical remediation guidance
- Understanding of attack chains and business impact

---

## SQL Injection in Rails controller
[snippet-1.rb with line numbers](snippet-1.rb)
```ruby
class ProjectsController < ApplicationController
  before_action :authenticate_user!

  def search
    @query = params[:search]
    
    if @query.present?
      @projects = Project.where("name LIKE '%#{@query}%' AND user_id = #{current_user.id}")
    else
      @projects = Project.where(user_id: current_user.id)
    end
    
    render json: @projects
  end
end
```

It is important to think out loud when reviewing this on a call so that the interviewer can understand your thought process.

- The method requires auth, `!` means redirects if not logged in so only authenticated users can access it.
- `@query` likely contains untrusted user data from the search parameter, this could be a __source__ (as in a __source__ and a __sink__).
- Line 13: in the `where` statement, string interpolation (concatenation) is used to craft the SQL query; this is not a great practice and parameterised statements should be used normally. In this case, because `query` could contain untrusted data, we're looking at a potential SQL injection vulnerability. Here, untrusted user data gets intepreted as code (SQL, e.g., by providing `query=' OR 1=1 --`). This might allow a malicious actor to manipulate the query and inject arbritrary SQL code, leaking sensitive data, running commands on the database server, or manipulating data affecting the confidentiality, integrity, and availability of the database and thus the service.
- If exploitable (e.g., there is no other controls in place such as a WAF or input validation), this would typically be rated a critical severity vulnerability that you want to fix as soon as possible. These issues can be generally easily found by SAST scanners. 
- The `current_user.id` in line 13 suffers from a similar problem, but it is likely not under direct control of an attacker. A better pattern is shown in the `else` condition in line 15, where parameters are used with ActiveRecord instead.

## Broken Access Control (IDOR) in user profile update
[snippet-2.rb with line numbers](snippet-2.rb)
```ruby
class UsersController < ApplicationController
  before_action :authenticate_user!

  def update_profile
    @user = User.find(params[:id])
    
    if @user.update(user_params)
      redirect_to profile_path(@user), notice: 'Profile updated successfully.'
    else
      render :edit
    end
  end

  private

  def user_params
    params.require(:user).permit(:firstname, :lastname, :email, :bio)
  end
end
```

- Again, this requires authentication.
- Line 10, user model is retrieved based on potentially untrusted data, `id` parameter. This might be problematic if there's no access checks in place. For an authenticated endpoint, you'd normally retrieve the user id from the trusted context, aka a user token or session.
- In line 12 the user gets updated based on `user_params`. It does not look like there are any access checks in place in this endpoint. While there might be an API server or authorization service elsewhere, this is likely a broken access control vulnerability via an indirect object reference (IDOR), via the `id` provided as parameter. This allows a malicious user to update any other user's data if no further controls are in place which could result in account take over and/or alteration of data. This is again critical depending on the user properties that can be updated.
- Looking at line 22, it allows for updating the names and `email`. If the `email` is also the username, it can likely be used for account takeover by updating `email` to an email under the attacker's control. After that, log in to the victim's user account via a password reset or passwordless login options - if there are no further protections in place such as "confirm email change" via the old email under the victim's control.
- There might also be a vector for stored Cross-Site Scripting (XSS), e.g., storing a malicious payload in the user profile including code that could steal session tokens. The next time a user's details are displayed in the app, the payload might trigger (blind XSS).

__(__Note that I skipped explaining potential fixes here to keep the initial response short - in a real interview, a follow up question is expected in such case to explore mitigation strategies.__

## Sensitive Data Exposure (password logging) in authentication
[snippet-3.rb with line numbers](snippet-3.rb)
```ruby
class SessionsController < ApplicationController
  def create
    user = User.find_by(email: params[:email])
    
    if user && user.authenticate(params[:password])
      session[:user_id] = user.id
      
      # Log the successful login
      Rails.logger.info "User login successful: #{params[:email]} from IP #{request.remote_ip} with password #{params[:password]}"
      
      redirect_to dashboard_path
    else
      flash[:error] = "Invalid email or password"
      render :new
    end
  end
  
  def destroy
    session[:user_id] = nil
    redirect_to root_path
  end
end
```

I'll keep it short now; just pointing out the most important things:
- Line 8: user object loaded by `email` parameter, possibly under user control. This seems off but wait, it looks like we're creating a session so that is expected.
- There is no input validation in this code and also no immediate rate limiting or other account lockout measures implemented. This can be hardened but let's focus on actual issues.
- Lack of logging when logins fail; this might not allow the security response team to identify password spraying or brute force attacks, amongst others.
- We shouldn't normally log the email address as this is often considered PII; it's better to log the user's id on successful login instead. Same for the IP; if this is considered sensitive data, it might be better to ommit it or redact a portion of the IP. If these details are critical for security and audit logs, make sure that the logs are encrypted and access restricted on a least privilege basis.
- Obviously the massive issue here is logging the password in plain text in the logs. This is really bad and allows anyone with access to the logs to login as any user that has previously logged in based on the email and password that are both exposed in the logs, unless additional factors are required to login (e.g., MFA). There is no excuse for logging passwords, ever. Even encrypting logs or restricting access is not appropriate.
- The session handling looks interesting as well. Depending on Ruby session management, there might be some issues here. Do you want me to consider this further?

## Path Traversal vulnerability in file handling
[snippet-4.rb with line numbers](snippet-4.rb)
```ruby
class DocumentsController < ApplicationController
  before_action :authenticate_user!

  def download
    filename = params[:file]
    filepath = Rails.root.join('public', 'documents', filename)
    
    if File.exist?(filepath)
      send_file filepath, disposition: 'attachment'
    else
      render plain: "File not found", status: :not_found
    end
  end
  
  def show_image
    image_path = params[:path]
    full_path = "/var/www/app/uploads/#{image_path}"
    
    if File.exist?(full_path)
      send_file full_path, type: 'image/jpeg', disposition: 'inline'
    else
      render plain: "Image not found", status: :not_found
    end
  end
end
```

Keeping it short again:
- Line 10/11 untrusted data in file path. This might or might not be vulnerable to path traversal depending on how Rails would normalise user data like `../../etc/passwd`.
- Looks like ANY file can be retrieved, just by providing the filename. There is a lack of access checks so again BAC IDOR. Given that this requires an authenticated user, the user should probably only be able to retrieve files from their own user folder or tenant directory. The fix here would be to validate the filename, make sure that it is normalised and valid, using expected characters only and a length check. Then implement access checks.
- Second issue is in `show_image`. This is definitely vulnerable to path traversal. This allows the retrieval of any file that this service has access to by providing a payload like `../../../../etc/passwd` which would retrieve sensitive data affecting the confidentiality of the app.
- There's again a lack of logging failures.
- Fixing the `show_image` handler would mean using the `Rails.root.join` as in the first snippet. Always use a secure API to interact with subsystems such as the file system or database. Also validate the path to ensure it is valid and expected, not allowing for path traversal and expected file types.

## Race Condition (TOCTOU) and CSRF in financial transaction API
[snippet-5.rb with line numbers](snippet-5.rb)
```ruby
class ApiController < ApplicationController
  skip_before_action :verify_authenticity_token
  before_action :authenticate_api_user!

  def transfer_funds
    amount = params[:amount].to_f
    recipient_id = params[:recipient_id]
    
    sender = current_user
    recipient = User.find(recipient_id)
    
    if sender.balance >= amount
      ActiveRecord::Base.transaction do
        sender.update!(balance: sender.balance - amount)
        recipient.update!(balance: recipient.balance + amount)
        
        Transfer.create!(
          sender_id: sender.id,
          recipient_id: recipient.id,
          amount: amount,
          status: 'completed'
        )
      end
      
      render json: { success: true, new_balance: sender.balance }
    else
      render json: { error: 'Insufficient funds' }, status: :unprocessable_entity
    end
  end
  
  private
  
  def authenticate_api_user!
    token = request.headers['Authorization']&.gsub('Bearer ', '')
    @current_user = User.find_by(api_token: token)
    
    unless @current_user
      render json: { error: 'Unauthorized' }, status: :unauthorized
    end
  end
end
```

`skip_before_action` disables anti-CSRF tokens in Ruby on Rails (also noted there's no `!`). This endpoint might be vulnerable to cross-site request forgery attacks which is likely not appropriate for a sensitive endpoint like this. This is likely an issue and this line simply needs to be removed to benefit from the standard Rails protection. This might require frontend/client changes to ensure the token is appended to each request.

There could be a time of check versus time of use issue here. The balance check needs to be within the transaction, it's currently outside. This must be fixed to guarantee that users can't end up with a negative balance. This can go wrong under a race condition or when many requests are being sent at once, potentially allowing someone to overdraw the account and "making" money into their own account affecting the integrity of the system.

There's no validation on untrusted input like `amount`, `recipient_id`. There should be a maximum amount and it must not be negative. Note the `.to_f` which converts this to a float. This conversion might fail and the app fails to handle this gracefully. This can go wrong and result in business logic issues if the conversion fails, also this might not be the best type in Ruby to deal with currency.

There's no check if the recipient is different than the sender, although it doesn't look immediately problematic here, combined with the timing issue above, this could be very problematic.

There doesn't seem to be any error handling in the transaction. If the one update fails but not the other, the transaction should be rolled back otherwise the account balances are in an incorrect state.

There's also a general lack of audit logging which is not appropriate for financial transactions.

In the `transfer.create`, the status is set to `completed` - this might be problematic if it fails. In line 30, the new balance is returned, it might not have been updated at that point. There is also a lack of validation in the token.

## Command Injection (RCE) and JWT vulnerabilities in Node.js/Express
See [snippet-6.ts with line numbers](snippet-6.ts) as this snippet is quite long.

- As this is a longer snippet, I quickly glimpsed over it first and it looks interesting; get the popcorn out!
- Line 7: importing `exec` is interesting as it suggest we might be running code on the underlying host/OS - need to look where this is used shortly.
- Line 11: default values when the secret is missing is not appropriate for a sensitive use case like this. This should erorr out and the service must not start when this value is missing otherwise it might fall back to an insecure default value.
- Line 19: lack of input validation on token; make sure it's in expected format before passing it to the JWT verifier (particularly length and characters).
- Line 25: the verify method does not explicitly set the JWT algorithm to use. This could be critical if the `None` algo is accepted or there might also be a case where an asymmetric algorithm's public key could get accepted for a symmetric key, meaning anyone can selfs-sign these tokens to impersonate a user (effectively account takeover again). Fix: need to provide the exact algorithm that is expected.
- Also, using a shared secret is not great. It would be better to use an asymmetric key algorithm with a private and public key. This also generally makes key rotation easier, as you could publish the public key in a key set and refer to the key id in the token.
- Line 34: `command` and `filename` taken from untrusted data inputs; must be validated and it looks like we're taking raw commands here. We'll get to the `exec` use soon, this is generally a very bad idea.
- Line 36: the admin role is part of the JWT; if any of the issues stated above can be used to forge a token, the user can also make themselves an admin and run arbitrary commands using this endpoint. This endpoint is questionable anyway, but make sure that this user property is not under the end user's control (e.g., fetch it from a permissions database or prevent someone to update this flag on the user object).
- Line 43: the `exec` allows ANY arbitrary command to be run; this is effectively a remote shell and a critical issue, compromising the underlying host and potentially anything that runs on it depending on the environment. The need to run system commands generally indicates an architectural weakness, but if you really have to, use a safe API to interact with the OS/shell. Provide the full path to the command, use an allowlist of valid commands, and pass the command arguments in a safe way so that they can't be leveraged to trigger command injection, e.g., via `/legit/cmd || cat /etc/passwd`.
- There's also a lack of logging again.
- Line 45: exposing raw error message including potentially the stack trace and sensitive values like the `JWT_SECRET` that is set on the environment.
- Quickly moving on to the last endpoint on lines 58+59: again untrusted data without validation. The user id is under the end user's control, should come from the JWT instead. The format is parsed as json without error handling or checks for length which could result in DoS attacks and other issues.
- Finally, SQL injection again, we've touched on it earlier, same here; use a safe API to interact with db, e.g., parameterised queries and/or prepared statements. This can be abused to retrieve unauthorised data from the db; this table or other tables including sensitive tables like a user data table. The result is just dumped as a JSON response, so all data is conveniently (for an attacker) being exposed.
- There is also error message leakage here again, which might be very useful to try to make an injection payload work as the database error would reveal why a query failed.

## Container security issues (secrets, root user, SSH exposure)
See [snippet-7.dockerfile with line numbers](snippet-7.dockerfile) for the Dockerfile.

`ubuntu` is quite a heavy image, consider using a vanilla image like Alpine or even distroless if possible to reduce the attack surface and only include what is required for the app to run. It's also best to use a separate build and runtime container.
`:latest` is non-deterministic; while it's great to run up-to-date software, this wouldn't allow for reproducable builds and it's better to bump the version regularly instead. Particularly in light of recent supply chain attacks (compromised dependencies), using `latest` might pull in malicious images without revewing/testing these first.

It is good to add a user for the app as is being done here but the app shouldn't run as root in line 52. The user should not have a password and even if they really require this, make sure it's not included in plain text in the Dockerfile and it must be a strong password.
Shouldn't give the user `sudo` permissions as it's effectively root, violating the principle of least privilege.

The `chmod` permissions are not appropriate as any user would be able to modify the folder; should be set to `700` or similar instead if possible.

Port 22 shouldn't be exposed as this would allow SSH sessions to the host, particularly problematic when exposed publicly. This is a bad practice and no direct access should be needed in production. If really required, use a bastion host or Systems Manager or other safer alternative, especially considering the weak and hardcoded password here.
Same with database credentials: provide as arguments instead and use a strong password or use roles instead.
Same with api key although this might be a public key, use an environment variable and store it securely.
This should not run in `debug` mode in non-dev environments and also with node in dev mode. 
Furthermore, it's weird to run two apps in the one container (Python and Node); would ask questions about this.
Starting the shell `/bin/bash` is not secure as it might allow anyone to run commands in the image.

--- 
*This can be used as part of interview preparation for application security engineering roles.*
